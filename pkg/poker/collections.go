package poker

import (
	"encoding/json"
	"sync"

	"github.com/google/uuid"
)

// Code generated by go-codegen(https://github.com/nchern/go-codegen).
// You COULD edit this code it you really need it and know what are you doing

// UserMapVisitor is a visitor function to visit map pairs
type UserMapVisitor func(uuid.UUID, *User) bool

// UserMap exposes the contract of UUID to UserPtr map
type UserMap interface {
	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor UserMapVisitor)

	// Get returns the value of a given key. If the key was not found the second return value will be false
	Get(key uuid.UUID) (v *User, found bool)

	// Length of this map
	Len() int

	// Set sets the value of a given key
	Set(key uuid.UUID, val *User)

	// Update updates a value by a given key
	Update(uuid.UUID, func(*User) error) error

	// Remove removes a given key from this map
	Remove(key uuid.UUID) bool

	// Clone creates a copy of this map
	Clone() UserMap

	// MarshalJSON implements json.Marshaler interface
	MarshalJSON() ([]byte, error)

	// UnmarshalJSON implements json.Marshaler interface
	UnmarshalJSON([]byte) error
}

type baseUUIDUserPtrMap struct {
	_map map[uuid.UUID]*User
}

// NewUserMap creates a basic instance of the UUIDUserPtrMap. It is _unsafe_ for concurrent access.
func NewUserMap() UserMap {
	res := &baseUUIDUserPtrMap{
		_map: map[uuid.UUID]*User{},
	}
	return res
}

// NewUserMapSyncronized creates a concurrent safe instance of the UUIDUserPtrMap
func NewUserMapSyncronized() UserMap {
	return &syncUserMap{
		inner: NewUserMap(),
	}
}

func (m *baseUUIDUserPtrMap) MarshalJSON() ([]byte, error) {
	return json.Marshal(m._map)
}

func (m *baseUUIDUserPtrMap) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &m._map)
}

func (m *baseUUIDUserPtrMap) Get(key uuid.UUID) (v *User, found bool) {
	v, found = m._map[key]
	return
}

func (m *baseUUIDUserPtrMap) Len() int { return len(m._map) }

func (m *baseUUIDUserPtrMap) Each(visitor UserMapVisitor) {
	for k, v := range m._map {
		if !visitor(k, v) {
			return
		}
	}
}

func (m *baseUUIDUserPtrMap) Set(key uuid.UUID, val *User) {
	m._map[key] = val
}

func (m *baseUUIDUserPtrMap) Update(id uuid.UUID, fn func(u *User) error) error {
	return fn(m._map[id])
}

func (m *baseUUIDUserPtrMap) Remove(key uuid.UUID) bool {
	_, found := m._map[key]
	delete(m._map, key)

	return found
}

func (m *baseUUIDUserPtrMap) Clone() UserMap {
	res := NewUserMap()
	for k, v := range m._map {
		res.Set(k, v)
	}

	return res
}

type syncUserMap struct {
	inner UserMap

	mutex sync.RWMutex
}

func (m *syncUserMap) MarshalJSON() ([]byte, error) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return json.Marshal(m.inner)
}

func (m *syncUserMap) UnmarshalJSON(b []byte) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	return m.inner.UnmarshalJSON(b)
}

func (m *syncUserMap) Len() int {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.inner.Len()
}

func (m *syncUserMap) Each(visitor UserMapVisitor) {
	m.mutex.RLock()
	m.inner.Each(visitor)
	m.mutex.RUnlock()
}

func (m *syncUserMap) Get(key uuid.UUID) (v *User, found bool) {
	m.mutex.RLock()
	v, found = m.inner.Get(key)
	m.mutex.RUnlock()
	return
}

func (m *syncUserMap) Set(key uuid.UUID, val *User) {
	m.mutex.Lock()
	m.inner.Set(key, val)
	m.mutex.Unlock()
}

func (m *syncUserMap) Update(id uuid.UUID, fn func(u *User) error) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	u, _ := m.inner.Get(id)
	return fn(u)
}

func (m *syncUserMap) Remove(key uuid.UUID) bool {
	m.mutex.Lock()
	found := m.inner.Remove(key)
	m.mutex.Unlock()

	return found
}

func (m *syncUserMap) Clone() UserMap {
	m.mutex.RLock()
	r := m.inner.Clone()
	m.mutex.RUnlock()
	return r
}

// TableMapVisitor is a visitor function to visit map pairs
type TableMapVisitor func(uuid.UUID, *Table) bool

// TableMap exposes the contract of UUID to TablePtr map
type TableMap interface {
	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor TableMapVisitor)

	// Get returns the value of a given key. If the key was not found the second return value will be false
	Get(key uuid.UUID) (v *Table, found bool)

	// Set sets the value of a given key
	Set(key uuid.UUID, val *Table)

	// Update updates the current map from a given map
	Update(src map[uuid.UUID]*Table) TableMap

	// Remove removes a given key from this map
	Remove(key uuid.UUID) bool

	// MarshalJSON implements json.Marshaler interface
	MarshalJSON() ([]byte, error)

	// UnmarshalJSON implements json.Marshaler interface
	UnmarshalJSON([]byte) error
}

type baseTableMap struct {
	_map map[uuid.UUID]*Table
}

// NewTableMap creates a basic instance of the UUIDTablePtrMap. It is _unsafe_ for concurrent access.
func NewTableMap() TableMap {
	res := &baseTableMap{
		_map: map[uuid.UUID]*Table{},
	}
	return res
}

// NewTableMapSyncronized creates a concurrent safe instance of the UUIDTablePtrMap
func NewTableMapSyncronized() TableMap {
	return &syncTableMap{
		inner: NewTableMap(),
	}
}

func (m *baseTableMap) Get(key uuid.UUID) (v *Table, found bool) {
	v, found = m._map[key]
	return
}

func (m *baseTableMap) Each(visitor TableMapVisitor) {
	for k, v := range m._map {
		if !visitor(k, v) {
			return
		}
	}
}

func (m *baseTableMap) Set(key uuid.UUID, val *Table) {
	m._map[key] = val
}

func (m *baseTableMap) Update(src map[uuid.UUID]*Table) TableMap {
	for k, v := range src {
		m._map[k] = v
	}
	return m
}

func (m *baseTableMap) MarshalJSON() ([]byte, error) {
	return json.Marshal(m._map)
}

func (m *baseTableMap) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &m._map)
}

func (m *baseTableMap) Remove(key uuid.UUID) bool {
	_, found := m._map[key]
	delete(m._map, key)

	return found
}

type syncTableMap struct {
	inner TableMap

	mutex sync.RWMutex
}

func (m *syncTableMap) Each(visitor TableMapVisitor) {
	m.mutex.RLock()
	m.inner.Each(visitor)
	m.mutex.RUnlock()
}

func (m *syncTableMap) Get(key uuid.UUID) (v *Table, found bool) {
	m.mutex.RLock()
	v, found = m.inner.Get(key)
	m.mutex.RUnlock()
	return
}

func (m *syncTableMap) Set(key uuid.UUID, val *Table) {
	m.mutex.Lock()
	m.inner.Set(key, val)
	m.mutex.Unlock()
}

func (m *syncTableMap) Update(src map[uuid.UUID]*Table) TableMap {
	m.mutex.Lock()
	m.inner.Update(src)
	m.mutex.Unlock()

	return m
}

func (m *syncTableMap) Remove(key uuid.UUID) bool {
	m.mutex.Lock()
	found := m.inner.Remove(key)
	m.mutex.Unlock()

	return found
}

func (m *syncTableMap) MarshalJSON() ([]byte, error) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return json.Marshal(m.inner)
}

func (m *syncTableMap) UnmarshalJSON(b []byte) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	return m.inner.UnmarshalJSON(b)
}
