// Code generated by go-codegen(https://github.com/nchern/go-codegen).
// You COULD edit this code it you really need it and know what are you doing

package models

import (
	"encoding/json"
	"sync"

	"github.com/google/uuid"
)

// UserMapVisitor is a visitor function to visit map pairs
type UserMapVisitor func(uuid.UUID, *User) bool

// UserMap exposes the contract of UUID to UserPtr map
type UserMap interface {
	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor UserMapVisitor)

	// Get returns the value of a given key. If the key was not found the second return value will be false
	Get(key uuid.UUID) (v *User, found bool)

	// Length of this map
	Len() int

	// Set sets the value of a given key
	Set(key uuid.UUID, val *User)

	// Update updates a value by a given key
	Update(uuid.UUID, func(*User) error) error

	// Remove removes a given key from this map
	Remove(key uuid.UUID) bool

	// Clone creates a copy of this map
	Clone() UserMap

	// MarshalJSON implements json.Marshaler interface
	MarshalJSON() ([]byte, error)

	// UnmarshalJSON implements json.Marshaler interface
	UnmarshalJSON([]byte) error
}

type baseUUIDUserPtrMap struct {
	_map map[uuid.UUID]*User
}

// NewUserMap creates a basic instance of the UUIDUserPtrMap. It is _unsafe_ for concurrent access.
func NewUserMap() UserMap {
	res := &baseUUIDUserPtrMap{
		_map: map[uuid.UUID]*User{},
	}
	return res
}

// NewUserMapSyncronized creates a concurrent safe instance of the UUIDUserPtrMap
func NewUserMapSyncronized() UserMap {
	return &syncUserMap{
		inner: NewUserMap(),
	}
}

func (m *baseUUIDUserPtrMap) MarshalJSON() ([]byte, error) {
	return json.Marshal(m._map)
}

func (m *baseUUIDUserPtrMap) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &m._map)
}

func (m *baseUUIDUserPtrMap) Get(key uuid.UUID) (v *User, found bool) {
	v, found = m._map[key]
	return
}

func (m *baseUUIDUserPtrMap) Len() int { return len(m._map) }

func (m *baseUUIDUserPtrMap) Each(visitor UserMapVisitor) {
	for k, v := range m._map {
		if !visitor(k, v) {
			return
		}
	}
}

func (m *baseUUIDUserPtrMap) Set(key uuid.UUID, val *User) {
	m._map[key] = val
}

func (m *baseUUIDUserPtrMap) Update(id uuid.UUID, fn func(u *User) error) error {
	return fn(m._map[id])
}

func (m *baseUUIDUserPtrMap) Remove(key uuid.UUID) bool {
	_, found := m._map[key]
	delete(m._map, key)

	return found
}

func (m *baseUUIDUserPtrMap) Clone() UserMap {
	res := NewUserMap()
	for k, v := range m._map {
		res.Set(k, v)
	}

	return res
}

type syncUserMap struct {
	inner UserMap

	mutex sync.RWMutex
}

func (m *syncUserMap) MarshalJSON() ([]byte, error) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return json.Marshal(m.inner)
}

func (m *syncUserMap) UnmarshalJSON(b []byte) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	return m.inner.UnmarshalJSON(b)
}

func (m *syncUserMap) Len() int {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return m.inner.Len()
}

func (m *syncUserMap) Each(visitor UserMapVisitor) {
	m.mutex.RLock()
	m.inner.Each(visitor)
	m.mutex.RUnlock()
}

func (m *syncUserMap) Get(key uuid.UUID) (v *User, found bool) {
	m.mutex.RLock()
	v, found = m.inner.Get(key)
	m.mutex.RUnlock()
	return
}

func (m *syncUserMap) Set(key uuid.UUID, val *User) {
	m.mutex.Lock()
	m.inner.Set(key, val)
	m.mutex.Unlock()
}

func (m *syncUserMap) Update(id uuid.UUID, fn func(u *User) error) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	u, _ := m.inner.Get(id)
	return fn(u)
}

func (m *syncUserMap) Remove(key uuid.UUID) bool {
	m.mutex.Lock()
	found := m.inner.Remove(key)
	m.mutex.Unlock()

	return found
}

func (m *syncUserMap) Clone() UserMap {
	m.mutex.RLock()
	r := m.inner.Clone()
	m.mutex.RUnlock()
	return r
}

// RoomMapVisitor is a visitor function to visit map pairs
type RoomMapVisitor func(uuid.UUID, *Room) bool

// RoomMap exposes the contract of UUID to RoomPtr map
type RoomMap interface {
	// Each visits each element in the map. It stops iterations if visitor func returns false
	Each(visitor RoomMapVisitor)

	// Get returns the value of a given key. If the key was not found the second return value will be false
	Get(key uuid.UUID) (v *Room, found bool)

	// Set sets the value of a given key
	Set(key uuid.UUID, val *Room)

	// Update updates the current map from a given map
	Update(src map[uuid.UUID]*Room) RoomMap

	// Remove removes a given key from this map
	Remove(key uuid.UUID) bool

	// MarshalJSON implements json.Marshaler interface
	MarshalJSON() ([]byte, error)

	// UnmarshalJSON implements json.Marshaler interface
	UnmarshalJSON([]byte) error
}

type baseRoomMap struct {
	_map map[uuid.UUID]*Room
}

// NewRoomMap creates a basic instance of the UUIDRoomPtrMap. It is _unsafe_ for concurrent access.
func NewRoomMap() RoomMap {
	res := &baseRoomMap{
		_map: map[uuid.UUID]*Room{},
	}
	return res
}

// NewRoomMapSyncronized creates a concurrent safe instance of the UUIDRoomPtrMap
func NewRoomMapSyncronized() RoomMap {
	return &syncRoomMap{
		inner: NewRoomMap(),
	}
}

func (m *baseRoomMap) Get(key uuid.UUID) (v *Room, found bool) {
	v, found = m._map[key]
	return
}

func (m *baseRoomMap) Each(visitor RoomMapVisitor) {
	for k, v := range m._map {
		if !visitor(k, v) {
			return
		}
	}
}

func (m *baseRoomMap) Set(key uuid.UUID, val *Room) {
	m._map[key] = val
}

func (m *baseRoomMap) Update(src map[uuid.UUID]*Room) RoomMap {
	for k, v := range src {
		m._map[k] = v
	}
	return m
}

func (m *baseRoomMap) MarshalJSON() ([]byte, error) {
	return json.Marshal(m._map)
}

func (m *baseRoomMap) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &m._map)
}

func (m *baseRoomMap) Remove(key uuid.UUID) bool {
	_, found := m._map[key]
	delete(m._map, key)

	return found
}

type syncRoomMap struct {
	inner RoomMap

	mutex sync.RWMutex
}

func (m *syncRoomMap) Each(visitor RoomMapVisitor) {
	m.mutex.RLock()
	m.inner.Each(visitor)
	m.mutex.RUnlock()
}

func (m *syncRoomMap) Get(key uuid.UUID) (v *Room, found bool) {
	m.mutex.RLock()
	v, found = m.inner.Get(key)
	m.mutex.RUnlock()
	return
}

func (m *syncRoomMap) Set(key uuid.UUID, val *Room) {
	m.mutex.Lock()
	m.inner.Set(key, val)
	m.mutex.Unlock()
}

func (m *syncRoomMap) Update(src map[uuid.UUID]*Room) RoomMap {
	m.mutex.Lock()
	m.inner.Update(src)
	m.mutex.Unlock()

	return m
}

func (m *syncRoomMap) Remove(key uuid.UUID) bool {
	m.mutex.Lock()
	found := m.inner.Remove(key)
	m.mutex.Unlock()

	return found
}

func (m *syncRoomMap) MarshalJSON() ([]byte, error) {
	m.mutex.RLock()
	defer m.mutex.RUnlock()
	return json.Marshal(m.inner)
}

func (m *syncRoomMap) UnmarshalJSON(b []byte) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	return m.inner.UnmarshalJSON(b)
}
